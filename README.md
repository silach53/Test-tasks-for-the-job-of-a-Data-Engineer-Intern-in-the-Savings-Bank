# Тестовые задания на вакансию Стажера Data Engineer в Сбере

Задание выполнено Алексеевым Александром

Язык выполнения: PostgreSQL

Далее приведены условия задач и их решение с объяснениями 

Для удобства проверки, код каждой задачи приведен на [Github](https://github.com/silach53/Test_tasks_Data_Engineer_Sber)

Тестовое задание
Примечание:

1. Можно использовать любой диалект SQL с его указанием при решении;
2. Краткость и форматирование кода приветствуются.

---

## Задача 1

Задание: необходимо найти 3-х самых молодых сотрудников в коллективе и выдать их имена,
предварительно отсортировав. Задачу требуется решить несколькими способами (чем больше, тем
лучше).
Можно использовать следующий ddl:

```cpp
create table test (id number, name varchar2(10),
 age number);
insert into test values (1, 'Вася', 23);
insert into test values (2, 'Петя', 40);
insert into test values (3, 'Маша', 19);
insert into test values (4, 'Марина', 23);
insert into test values (5, 'Сергей', 34);
```

### Решение задачи 1

Ниже приведены несколько способов найти 3-х самых молодых сотрудников в команде и вывести их имена в отсортированном виде.

Создадим таблицу на PostgreSQL

```sql
CREATE TABLE test (
  id INT,
  name VARCHAR(10),
  age INT
);

INSERT INTO test VALUES 
(1, 'Вася', 23),
(2, 'Петя', 40),
(3, 'Маша', 19),
(4, 'Марина', 23),
(5, 'Сергей', 34);
```

### Решение 1_1: Использующее **`LIMIT` и `ORDER BY`**

```sql
SELECT name
FROM test
ORDER BY age, name
LIMIT 3;
```

Этот запрос сортирует сотрудников по возрасту в порядке возрастания, а затем по имени. Он использует **`LIMIT`** для возврата только первых 3 строк отсортированного результирующего набора.

### Решение 1_2: Использующее **`JOIN` и `GROUP BY`**

```sql
SELECT t1.name
FROM test t1
LEFT JOIN test t2 ON t1.age > t2.age
GROUP BY t1.id, t1.name, t1.age
HAVING COUNT(t2.id) < 3
ORDER BY t1.age, t1.name;
```

В этом альтернативном решении мы выполняем  `LEFT JOIN` на `test` таблице, объединяя строки, где возраст первой таблицы (`t1`) больше возраста второй таблицы (`t2`). Затем мы группируем результаты по столбцам `id`, `name` и `age` первой таблицы и используем `HAVING` для фильтрации групп с количеством строк меньше 3 из второй таблицы (`t2`). Это означает, что мы выбираем только 3 самых молодых сотрудников. Наконец, мы сортируем результаты по возрасту и имени.

### Решение 1_3: Использующее  **`RANK()`**

```sql
SELECT name
FROM (
  SELECT name, age, RANK() OVER (ORDER BY age, name) AS rank
  FROM test
) AS ranked_employees
WHERE rank <= 3;
```

В данном решении используется оконная функция RANK() для присвоения ранга каждому сотруднику на основе его возраста и имени. Затем набор результатов фильтруется, чтобы включить только сотрудников с рангом 3 или ниже.

Все эти решения приведут к одному и тому же результату - отсортированным именам 3-х самых молодых сотрудников. Первое решение является наиболее кратким и простым для понимания. Второе решение использует join и group by, которые полезны во множестве случаев. Третье решение демонстрирует использование оконных функций, которые могут быть полезны в более сложных сценариях.

### Результат всех команд

```
CREATE TABLE
INSERT 0 5
  name  
--------
 Маша
 Вася
 Марина
(3 rows)
```

---

## Задача 2

Есть таблица:

| abonent  | region_id | dttm |
| --- | --- | --- |
| 7072110988  | 32722 | 2021-08-18 13:15 |
| 7072110988 | 32722 | 2021-08-18 14:00 |
| 7072110988  | 21534 | 2021-08-18 14:15 |
| 7072110988 | 32722  | 2021-08-19 09:00 |
| 7071107101  | 12533  | 2021-08-19 09:15 |
| 7071107101  | 32722  | 2021-08-19 09:27 |

 Описание атрибутов:

1. abonent – номер абонента;
2. region_id – id региона в котором находится абонент;
3. dttm – день и время звонка.

Задание: нужно для каждого дня определить последнее местоположение абонента.
То есть нужно вывести:

| abonent  | region_id | dttm |
| --- | --- | --- |
| 7072110988  | 21534 | 2021-08-18 14:15 |
| 7072110988 | 32722  | 2021-08-19 09:00 |
| 7071107101  | 32722  | 2021-08-19 09:27 |

### Решение задачи 2

Код на PostgreSQL для создания таблицы и вставки данных:

```sql
CREATE TABLE calls (
	abonent BIGINT,
	region_id INT,
	dttm TIMESTAMP
);

INSERT INTO calls (abonent, region_id, dttm) VALUES
(7072110988, 32722, '2021-08-18 13:15'),
(7072110988, 32722, '2021-08-18 14:00'),
(7072110988, 21534, '2021-08-18 14:15'),
(7072110988, 32722, '2021-08-19 09:00'),
(7071107101, 12533, '2021-08-19 09:15'),
(7071107101, 32722, '2021-08-19 09:27');
```

Теперь я предоставлю запрос для определения последнего местоположения подписчика за каждый день:

```sql
WITH last_location AS (
    SELECT 
        abonent,
        MAX(dttm) AS dttm
    FROM calls
    GROUP BY abonent, DATE(dttm)
)
SELECT 
    ll.abonent,
    c.region_id,
    ll.dttm
FROM last_location ll
JOIN calls c ON ll.abonent = c.abonent AND ll.dttm = c.dttm
ORDER BY ll.abonent, ll.dttm;
```

1. Создается общий таблицы выражений (CTE) с названием **`last_location`**, чтобы найти максимальную (последнюю) метку времени (**`dttm`**) для каждого абонента (**`abonent`**) и дня. Это делается путем группировки данных по **`abonent`** и части даты **`dttm`** (с использованием функции **`DATE()`**), а затем выбора максимального значения **`dttm`** для каждой группы.
2. Затем основной запрос выбирает столбцы **`abonent`**, **`region_id`** и **`dttm`** из CTE **`last_location`** и исходной таблицы **`calls`**.
3. CTE **`last_location`** объединяется с таблицей **`calls`** на основе совпадающих значений **`abonent`** и совпадающих значений **`dttm`** (т. е. последняя метка времени для каждого абонента и дня).
4. Наконец, запрос упорядочивает результат по **`abonent`** и **`dttm`**.

### Результат всех команд

```
CREATE TABLE
INSERT 0 6
  abonent   | region_id |        dttm         
------------+-----------+---------------------
 7071107101 |     32722 | 2021-08-19 09:27:00
 7072110988 |     21534 | 2021-08-18 14:15:00
 7072110988 |     32722 | 2021-08-19 09:00:00
(3 rows)
```

---

### Задача 3

Есть таблица item_prices:

| Название столбца | Тип  | Описание |
| --- | --- | --- |
| item_id  | number(21,0)  | Идентификатор товара |
| item_name  |  varchar2(150) | Название товара |
| item_price | number(12,2) | Цена товара |
| created_dttm | created_dttm | Дата добавления записи |

Задание: необходимо сформировать таблицу следующего вида dict_item_prices.

Название столбца Тип Описание

| Название столбца | Тип  | Описание |
| --- | --- | --- |
| item_id  | Идентификатор  | Идентификатор товара |
| item_name  |  varchar2(150) | Название товара |
| item_price | number(12,2) | Цена товара |
| valid_from_dt  | date |  Дата, с которой начала действовать данная цена (created_dttm записи с ценой) |
| valid_to_dt  | date  | Дата, до которой действовала данная цена (created_dttm следующей записи по данному товару «минус» один день) |

Примечание: для последней (действующей на данный момент) цены устанавливается дата 9999-12-31.

### Решение задачи 3

Сначала давайте создадим таблицу `item_prices` и вставим некоторые примеры данных:

```sql
CREATE TABLE item_prices (
    item_id INT,
    item_name VARCHAR(150),
    item_price NUMERIC(12, 2),
    created_dttm TIMESTAMP
);

INSERT INTO item_prices (item_id, item_name, item_price, created_dttm) VALUES
    (1, 'Product A', 10.00, '2022-01-01'),
    (1, 'Product A', 12.00, '2022-02-01'),
    (2, 'Product B', 15.00, '2022-01-15'),
    (2, 'Product B', 16.00, '2022-02-15'),
    (2, 'Product B', 18.00, '2022-03-01');
```

Теперь давайте создадим запрос, который выведет таблицу `dict_item_prices`, как описано:

```sql
SELECT
    ip.item_id,
    ip.item_name,
    ip.item_price,
    ip.created_dttm AS valid_from_dt,
    COALESCE((LEAD(ip.created_dttm) OVER (PARTITION BY ip.item_id ORDER BY ip.created_dttm))::date - INTERVAL '1 DAY', '9999-12-31') AS valid_to_dt
FROM
    item_prices ip
ORDER BY
    ip.item_id, ip.created_dttm;
```

1. Оператор **`SELECT`** выбирает столбцы **`item_id`**, **`item_name`**, **`item_price`** и **`created_dttm`** из таблицы **`item_prices`**. Столбец **`created_dttm`** также используется в качестве столбца **`valid_from_dt`**, поскольку он представляет дату, с которой цена стала действительной.
2. Столбец **`valid_to_dt`** вычисляется с помощью функции окон **`LEAD()`**, которая извлекает значение **`created_dttm`** из следующей строки (сортируемой по **`created_dttm`**) в рамках той же группы **`item_id`** (разделенной с помощью **`PARTITION BY`**). Функция **`LEAD()`** возвращает следующее значение **`created_dttm`** минус один день (используя выражение **`INTERVAL '1 DAY'`**), чтобы получить дату, до которой действовала текущая цена. Если для текущего **`item_id`** нет следующего значения **`created_dttm`** (т.е. текущая цена является последней ценой для продукта), используется функция **`COALESCE()`**, чтобы вернуть дату '9999-12-31', указывающую, что текущая цена все еще действительна.
3. Оператор **`FROM`** указывает исходную таблицу **`item_prices`** (с псевдонимом **`ip`**).
4. Оператор **`ORDER BY`** сортирует строки вывода по **`item_id`** и **`created_dttm`**.

### Результат всех команд

```
REATE TABLE
INSERT 0 5
 item_id | item_name | item_price |    valid_from_dt    |     valid_to_dt     
---------+-----------+------------+---------------------+---------------------
       1 | Product A |      10.00 | 2022-01-01 00:00:00 | 2022-01-31 00:00:00
       1 | Product A |      12.00 | 2022-02-01 00:00:00 | 9999-12-31 00:00:00
       2 | Product B |      15.00 | 2022-01-15 00:00:00 | 2022-02-14 00:00:00
       2 | Product B |      16.00 | 2022-02-15 00:00:00 | 2022-02-28 00:00:00
       2 | Product B |      18.00 | 2022-03-01 00:00:00 | 9999-12-31 00:00:00
(5 rows)
```

---

## Задача 4

Есть исходная таблица детализации по транзакциям transaction_details:

| Название столбца | Тип | Описание |
| --- | --- | --- |
| transaction_id | number(21,0) | Идентификатор транзакции |
| customer_id  | number(21,0) | Идентификатор клиента |
| item_id | number(21,0) | Идентификатор товара |
| item_number | number(8,0) | Количество купленных единиц товара |
| transaction_dttm | timestamp |  Дата-время транзакции |

Задание: необходимо сформировать таблицу следующего вида customer_aggr:

| Название столбца | Тип | Описание |
| --- | --- | --- |
| customer_id | number(21,0) | Идентификатор клиента |
| amount_spent_1m  | number(12,2)  | Потраченная клиентом сумма за последний месяц |
| top_item_1m | varchar2(150)  | Товар (item_name), на который за последний месяц клиент потратил больше всего |

 Примечание:
• при расчете необходимо учитывать актуальную цену на момент совершения транзакции (по
справочнику dict_item_prices из Задача 3);
• клиенты, не совершавшие покупок в последний месяц, в итоговую таблицу не попадают;
• последний месяц определяется как последние 30 дней на момент построения отчета.

### Решение задачи 4

Сначала давайте создадим таблицу `transaction_details` и вставим некоторые примеры данных:

```sql
CREATE TABLE transaction_details (
    transaction_id INT,
    customer_id INT,
    item_id INT,
    item_number INT,
    transaction_dttm TIMESTAMP
);

INSERT INTO transaction_details (transaction_id, customer_id, item_id, item_number, transaction_dttm) VALUES
    (1, 100, 1, 2, '2022-08-10 10:00:00'),
    (2, 100, 2, 1, '2022-08-20 14:00:00'),
    (3, 100, 1, 3, '2022-09-01 09:00:00'),
    (4, 200, 2, 2, '2022-08-15 16:00:00'),
    (5, 200, 1, 1, '2022-08-25 11:00:00'),
    (6, 200, 2, 4, '2022-09-05 13:00:00'),
    (7, 300, 1, 2, '2023-03-05 10:00:00'),
    (8, 300, 2, 3, '2023-03-10 14:00:00'),
    (9, 300, 1, 4, '2023-03-15 09:00:00'),
    (10, 400, 2, 2, '2023-03-20 16:00:00'),
    (11, 400, 1, 3, '2023-03-25 11:00:00'),
    (12, 400, 2, 1, '2023-03-26 13:00:00');
```

А также таблицу **`item_prices`:**

```sql
CREATE TABLE item_prices (
    item_id INT,
    item_name VARCHAR(150),
    item_price NUMERIC(12, 2),
    valid_from_dt TIMESTAMP,
    valid_to_dt TIMESTAMP
);

INSERT INTO item_prices (item_id, item_name, item_price, valid_from_dt, valid_to_dt) VALUES
    (1, 'Product A', 10.00, '2022-01-01', '2022-02-01'),
    (1, 'Product A', 12.00, '2022-02-01', '9999-12-31'),
    (2, 'Product B', 15.00, '2022-01-15', '2022-02-15'),
    (2, 'Product B', 16.00, '2022-02-15', '2022-03-01'),
    (2, 'Product B', 18.00, '2022-03-01', '9999-12-31');
```

Теперь давайте создадим запрос, который выведет таблицу **`customer_aggr`**:

```sql
WITH last_month_transactions AS (
    SELECT
        td.customer_id,
        td.item_id,
        td.item_number,
        td.transaction_dttm
    FROM
        transaction_details td
    WHERE
        td.transaction_dttm > CURRENT_DATE - INTERVAL '30 DAY'
),
transaction_prices AS (
    SELECT
        lmt.customer_id,
        lmt.item_id,
        lmt.item_number,
        lmt.transaction_dttm,
        ip.item_name,
        ip.item_price
    FROM
        last_month_transactions lmt
    JOIN
        item_prices ip ON lmt.item_id = ip.item_id AND lmt.transaction_dttm BETWEEN ip.valid_from_dt AND ip.valid_to_dt
),
total_spent AS (
    SELECT
        customer_id,
        item_name,
        SUM(item_number * item_price) AS amount_spent
    FROM
        transaction_prices
    GROUP BY
        customer_id, item_name
),
max_spent AS (
    SELECT
        customer_id,
        MAX(amount_spent) AS max_amount_spent
    FROM
        total_spent
    GROUP BY
        customer_id
)
SELECT
    tp.customer_id,
    tp.amount_spent AS amount_spent_1m,
    tp.item_name AS top_item_1m
FROM
    total_spent tp
JOIN
    max_spent ms ON tp.customer_id = ms.customer_id AND tp.amount_spent = ms.max_amount_spent
ORDER BY
    tp.customer_id;
```

Запрос состоит из нескольких общих выражений (CTE), которые разбивают проблему на более мелкие части. Вот объяснение каждой части:

1. **`last_month_transactions`**: Это CTE фильтрует таблицу **`transaction_details`**, чтобы включить только транзакции, которые произошли в последние 30 дней.
2. **`transaction_prices`**: Это CTE объединяет CTE **`last_month_transactions`** с таблицей **`item_prices`**, чтобы получить названия товаров и их цены для каждой транзакции, учитывая период действия цены.
3. **`total_spent`**: Это CTE рассчитывает общую сумму, потраченную каждым клиентом на каждый товар в течение последнего месяца, суммируя произведение **`item_number`** и **`item_price`**.
4. **`max_spent`**: Это CTE определяет максимальную сумму, потраченную каждым клиентом на любой товар за последний месяц.
5. Финальный SELECT-запрос объединяет CTE **`total_spent`** и **`max_spent`**, чтобы получить список наиболее дорогих товаров (названия товаров), на которые каждый клиент потратил больше всего в течение последнего месяца, а также общую сумму, потраченную на этот товар. Результаты упорядочены по **`customer_id`**.

### Результат всех команд

```
CREATE TABLE
INSERT 0 12
CREATE TABLE
INSERT 0 5
 customer_id | amount_spent_1m | top_item_1m 
-------------+-----------------+-------------
         300 |           72.00 | Product A
         400 |           54.00 | Product B
(2 rows)
```

---

## Задача 5

Существует таблица публикаций posts в социальных сетях с указанием даты и названием публикации.
Задание: рассчитать количество публикаций в месяц с указанием первой даты месяца и долей
увеличения количества сообщений (публикаций) относительно предыдущего месяца.
Данные в результирующей таблице должны быть упорядочены в хронологическом порядке.
Примечание: доля увеличения количества сообщений может быть отрицательной, а результат должен
быть округлен до одного знака после запятой с добавлением знака %.

Table posts (пример)

| id | created_at | title |
| --- | --- | --- |
| 1 | 2022-01-17 08:50:58 | Sberbank is the best bank |
| 2 | 2022-01-17 18:36:41 | Visa vs Mastercard |
| 3 | 2022-01-17 16:16:17 | Visa vs UnionPay |
| 4 | 2022-01-17 18:01:00 | Mastercard vs UnionPay |
| 5 | 2022-01-16 16:44:36 | Hadoop or Greenplum: pros and cons |
| 6 | 2022-01-16 14:57:32 | NFC: wireless payment |

Table results (пример для наглядного результата, с таблицей posts не соотносится 1 к 1)

| dt  | count | prcnt_growth |
| --- | --- | --- |
| 2022-02-01 | 175 | null |
| 2022-03-01 | 338 | 93.1% |
| 2022-04-01  | 345  | 2.1% |
| 2022-05-01 | 295 | -14.5% |
| 2022-06-01 | 330  | 11.9% |

### Решение задачи 5

Сначала давайте создадим таблицу **`social_posts`** и вставим некоторые примеры данных:

```sql
CREATE TABLE social_posts (
    id INT,
    created_at TIMESTAMP,
    header VARCHAR(255)
);

INSERT INTO social_posts (id, created_at, header) VALUES
		-- February
    (1, '2022-02-01 08:50:58', 'Post 1'),
    (2, '2022-02-02 18:36:41', 'Post 2'),
    (3, '2022-02-10 16:16:17', 'Post 3'),
    (4, '2022-02-15 18:01:00', 'Post 4'),
    (5, '2022-02-28 16:44:36', 'Post 5'),

		-- March
    (6, '2022-03-01 14:57:32', 'Post 6'),
    (7, '2022-03-02 09:30:20', 'Post 7'),
    (8, '2022-03-05 11:55:12', 'Post 8'),
    (9, '2022-03-08 13:05:43', 'Post 9'),
    (10, '2022-03-10 15:25:31', 'Post 10'),
    (11, '2022-03-12 17:40:55', 'Post 11'),
    (12, '2022-03-15 10:07:29', 'Post 12'),
    (13, '2022-03-18 12:33:46', 'Post 13'),
    (14, '2022-03-22 14:12:59', 'Post 14'),
    (15, '2022-03-25 16:23:17', 'Post 15'),
    (16, '2022-03-28 18:45:34', 'Post 16'),
    (17, '2022-03-30 09:15:41', 'Post 17'),
    (18, '2022-03-31 11:24:53', 'Post 18'),

		-- April
    (19, '2022-04-01 12:35:16', 'Post 19'),
    (20, '2022-04-04 14:46:58', 'Post 20'),
    (21, '2022-04-06 10:20:42', 'Post 21'),
    (22, '2022-04-09 12:55:30', 'Post 22'),
    (23, '2022-04-12 14:07:15', 'Post 23'),
    (24, '2022-04-15 15:22:49', 'Post 24'),
    (25, '2022-04-18 10:33:24', 'Post 25'),
    (26, '2022-04-20 12:45:38', 'Post 26'),
    (27, '2022-04-25 14:55:38', 'Post 27'),

		-- May
    (28, '2022-05-01 09:32:01', 'Post 28'),
    (29, '2022-05-06 10:20:42', 'Post 29'),
    (30, '2022-05-09 12:55:30', 'Post 30'),
    (31, '2022-05-12 14:07:15', 'Post 31'),
    (32, '2022-05-25 11:42:52', 'Post 32'),

    -- June
    (33, '2022-06-01 08:55:37', 'Post 33'),
    (34, '2022-06-01 09:32:01', 'Post 34'),
    (35, '2022-06-06 10:20:42', 'Post 35'),
    (36, '2022-06-09 12:55:30', 'Post 36'),
    (37, '2022-06-28 16:30:18', 'Post 37');
```

Теперь давайте создадим запрос, который выдаст желаемый результат:

```sql
WITH monthly_counts AS (
    SELECT
        DATE_TRUNC('month', created_at) AS dt,
        COUNT(*) AS count
    FROM
        social_posts
    GROUP BY
        DATE_TRUNC('month', created_at)
),
percentage_growth AS (
    SELECT
        mc.dt,
        mc.count,
        ROUND(100 * (mc.count - LAG(mc.count) OVER (ORDER BY mc.dt)) / LAG(mc.count) OVER (ORDER BY mc.dt),1) AS prcnt_growth
    FROM
        monthly_counts mc
)
SELECT
    dt,
    count,
    COALESCE(CAST(prcnt_growth AS VARCHAR) || '%', 'zero') AS prcnt_growth
FROM
    percentage_growth
ORDER BY
    dt;
```

Запрос использует два Common Table Expressions (CTE). Первый CTE, **`monthly_counts`**, вычисляет количество записей за каждый месяц путем усечения временной метки до уровня месяца, а затем группировки и подсчета записей. Второй CTE, **`percentage_growth`**, вычисляет процентный рост количества сообщений по сравнению с предыдущим месяцем, используя оконную функцию **`LAG()`**.

Наконец, основная инструкция SELECT извлекает столбцы **`dt`**, **`количество`** и **`prcnt_growth`**. Если **`prcnt_growth`** равно NULL, вместо него используется строка 'zero'. Результаты упорядочены по столбцу **`dt`** в порядке возрастания.

### Результат всех команд

```
CREATE TABLE
INSERT 0 37
         dt | count | prcnt_growth 
------------+-------+--------------
 2022-02-01 |     5 | zero
 2022-03-01 |    13 | 160.0%
 2022-04-01 |     9 | -30.0%
 2022-05-01 |     5 | -44.0%
 2022-06-01 |     5 | 0.0%
(5 rows)
```
